<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Index of / - Advanced File Storage & Pastebin</title>
    <meta
      name="description"
      content="File listing, upload, and persistent text/image pasting."
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body class="dark:bg-gray-900">
    <nav class="pkm-nav">
      <span class="brand">PKM System</span>
      <a href="https://memor.ia.br/?b=inbox" title="Tasks and Notes"
        >Workshop</a
      >
      <a href="https://arcreformas.com.br" title="File Storage">Storage</a>
      <a href="https://cut.ia.br" title="Capture and Tools">Gateway</a>
      <a
        href="https://ib-bsb-br.github.io/"
        title="Public Site"
        target="_blank"
        rel="noopener"
        >Published</a
      >
    </nav>
    <div class="header-bar dark:bg-gray-800">
      <h1 class="text-white">Advanced File Storage & Pastebin</h1>
    </div>

    <div class="container dark:bg-gray-800 dark:border-gray-700">
      <div id="uploadSection" class="dark:bg-gray-700 dark:border-gray-600">
        <h2
          class="text-2xl font-semibold mb-5 text-gray-800 dark:text-gray-200"
        >
          Upload New File
        </h2>
        <form id="uploadForm" enctype="multipart/form-data">
          <div>
            <label for="fileToUpload" class="text-gray-700 dark:text-gray-300"
              >Choose file to upload:</label
            >
            <input
              type="file"
              name="fileToUpload"
              id="fileToUpload"
              required
              class="dark:bg-gray-600 dark:border-gray-500 dark:text-gray-200 dark:placeholder-gray-400"
            />
          </div>
          <button
            type="submit"
            id="uploadButton"
            class="dark:bg-blue-600 dark:hover:bg-blue-700"
          >
            <span class="spinner"></span>
            <span class="button-text">Upload File</span>
          </button>
        </form>
        <progress id="uploadProgress" value="0" max="100"></progress>
        <div id="uploadStatus" class="message-base mt-4"></div>
      </div>

      <div
        id="pasteContentSection"
        class="dark:bg-gray-700 dark:border-gray-600"
      >
        <h2
          class="text-2xl font-semibold mb-5 text-gray-800 dark:text-gray-200"
        >
          Create File from Text or Pasted Image
        </h2>
        <form id="pasteContentForm">
          <div>
            <label for="pasteArea" class="text-gray-700 dark:text-gray-300"
              >Enter text or paste image here:</label
            >
            <textarea
              id="pasteArea"
              name="pasteData"
              rows="8"
              placeholder="Type text directly, or paste an image from your clipboard (Ctrl+V or Cmd+V)."
              class="dark:bg-gray-600 dark:border-gray-500 dark:text-gray-200 dark:placeholder-gray-400"
            ></textarea>
          </div>
          <div
            id="imagePreviewContainer"
            style="display: none"
            class="dark:bg-gray-600 p-2 rounded my-2"
          >
            <p class="text-sm text-gray-600 dark:text-gray-400 mb-1">
              Pasted image preview:
            </p>
            <img
              id="imagePreview"
              src="#"
              alt="Pasted image"
              class="max-w-full max-h-48 border border-gray-400 dark:border-gray-500 rounded-md shadow-sm"
            />
          </div>
          <div class="mt-4">
            <label
              for="pasteOptionalFilename"
              class="text-gray-700 dark:text-gray-300"
              >Optional Filename (extension added automatically):</label
            >
            <input
              type="text"
              id="pasteOptionalFilename"
              name="pasteOptionalFilename"
              placeholder="e.g., my_notes or cool_image_idea"
              class="dark:bg-gray-600 dark:border-gray-500 dark:text-gray-200 dark:placeholder-gray-400"
            />
          </div>
          <button
            type="submit"
            id="savePastedContentButton"
            class="dark:bg-green-600 dark:hover:bg-green-700 mt-2"
          >
            <span class="spinner"></span>
            <span class="button-text">Save Text as File</span>
          </button>
        </form>
        <progress id="pasteProgress" value="0" max="100"></progress>
        <div id="pasteStatus" class="message-base mt-4"></div>
      </div>

      <h2
        class="text-2xl font-semibold mb-5 text-gray-800 dark:text-gray-200 mt-8"
      >
        Stored Files
      </h2>
      <div
        id="statusMessage"
        class="message-base info-message"
        style="display: block"
      >
        Listed 0 item(s). Total files size: 0 B.
      </div>

      <div class="overflow-x-auto">
        <table
          id="fileTable"
          class="mt-1 min-w-full dark:border-gray-600"
          style="display: none"
        >
          <thead class="dark:bg-gray-700">
            <tr>
              <th
                class="icon-cell dark:text-gray-300"
                title="Icon"
                aria-label="Icon"
              ></th>
              <th
                data-sort="name"
                title="Sort by Name"
                aria-sort="ascending"
                class="sort-asc dark:text-gray-300"
              >
                Name
              </th>
              <th
                data-sort="displayType"
                title="Sort by Type"
                aria-sort="none"
                class="dark:text-gray-300"
              >
                Type
              </th>
              <th
                data-sort="size"
                class="size-cell dark:text-gray-400"
                title="Sort by Size"
                aria-sort="none"
              >
                Size
              </th>
              <th
                data-sort="lastModified"
                class="date-cell dark:text-gray-400"
                title="Sort by Last Modified"
                aria-sort="none"
              >
                Last Modified
              </th>
            </tr>
          </thead>
          <tbody id="fileTableBody" class="dark:bg-gray-800"></tbody>
        </table>
      </div>
    </div>

    <script>
      // --- CONFIGURATION ---
      const API_BASE_URL = "/api";
      const CUT_PUBLISH_ENDPOINT = "https://cut.ia.br/?op=publish_md"; // leave as '' to hide Publish buttons
      const PUBLISH_ENABLED = !!CUT_PUBLISH_ENDPOINT;

      // --- GLOBAL STATE ---
      let currentSortColumn = "lastModified";
      let currentSortDirection = "desc";
      let filesData = [];
      let currentPastedImageFile = null;
      let lastFilesETag = localStorage.getItem("filesETag") || "";

      // Client-side size limits
      const MAX_CLIENT_IMAGE_PASTE_SIZE = 10 * 1024 * 1024; // 10MB
      const MAX_CLIENT_TEXT_CONTENT_SIZE = 2 * 1024 * 1024; // 2MB

      // --- DOM Elements ---
      const uploadFormEl = document.getElementById("uploadForm");
      const fileInputEl = document.getElementById("fileToUpload");
      const uploadButtonEl = document.getElementById("uploadButton");
      const uploadButtonTextEl = uploadButtonEl.querySelector(".button-text");
      const uploadButtonSpinnerEl = uploadButtonEl.querySelector(".spinner");
      const uploadProgressEl = document.getElementById("uploadProgress");
      const pasteContentFormEl = document.getElementById("pasteContentForm");
      const pasteAreaEl = document.getElementById("pasteArea");
      const imagePreviewContainerEl = document.getElementById(
        "imagePreviewContainer",
      );
      const imagePreviewEl = document.getElementById("imagePreview");
      const pasteOptionalFilenameEl = document.getElementById(
        "pasteOptionalFilename",
      );
      const savePastedContentButtonEl = document.getElementById(
        "savePastedContentButton",
      );
      const savePastedContentButtonTextEl =
        savePastedContentButtonEl.querySelector(".button-text");
      const savePastedContentButtonSpinnerEl =
        savePastedContentButtonEl.querySelector(".spinner");
      const pasteProgressEl = document.getElementById("pasteProgress");

      function formatSize(bytes) {
        if (bytes === null || bytes === undefined || isNaN(parseFloat(bytes)))
          return "‚Äî";
        bytes = Number(bytes);
        if (bytes === 0) return "0 B";
        const k = 1024;
        const sizes = ["B", "KB", "MB", "GB", "TB", "PB"];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
      }
      function formatDate(dateString) {
        if (!dateString) return "‚Äî";
        try {
          const date = new Date(dateString);
          if (isNaN(date.getTime())) return "‚Äî";
          const year = date.getFullYear();
          const month = ("0" + (date.getMonth() + 1)).slice(-2);
          const day = ("0" + date.getDate()).slice(-2);
          const hours = ("0" + date.getHours()).slice(-2);
          const minutes = ("0" + date.getMinutes()).slice(-2);
          return `${year}-${month}-${day} ${hours}:${minutes}`;
        } catch (e) {
          console.error("Error formatting date:", dateString, e);
          return "‚Äî";
        }
      }
      function getIcon(type, name) {
        if (type === "folder") return "üìÅ";
        const extension = name.includes(".")
          ? name.split(".").pop().toLowerCase()
          : "";
        const iconMap = {
          image: [
            "jpg",
            "jpeg",
            "png",
            "gif",
            "webp",
            "svg",
            "bmp",
            "ico",
            "heic",
            "heif",
          ],
          video: [
            "mp4",
            "webm",
            "mov",
            "avi",
            "mkv",
            "flv",
            "wmv",
            "m4v",
            "mpg",
            "mpeg",
          ],
          audio: ["mp3", "wav", "ogg", "aac", "flac", "m4a", "wma"],
          pdf: ["pdf"],
          document: ["doc", "docx", "odt", "rtf", "pages", "tex", "wpd"],
          spreadsheet: ["xls", "xlsx", "ods", "csv", "numbers"],
          presentation: ["ppt", "pptx", "odp", "key"],
          archive: ["zip", "rar", "tar", "gz", "7z", "bz2", "xz", "iso"],
          text: [
            "txt",
            "md",
            "log",
            "ini",
            "conf",
            "json",
            "xml",
            "yaml",
            "cfg",
            "srt",
          ],
          code: [
            "js",
            "html",
            "css",
            "php",
            "py",
            "java",
            "c",
            "cpp",
            "cs",
            "rb",
            "go",
            "swift",
            "kt",
            "sh",
            "bat",
            "ps1",
            "sql",
          ],
          executable: ["exe", "dmg", "app", "msi", "deb", "rpm", "bin"],
          font: ["ttf", "otf", "woff", "woff2"],
        };
        const iconChars = {
          image: "üñºÔ∏è",
          video: "üéûÔ∏è",
          audio: "üéµ",
          pdf: "üìï",
          document: "üìÑ",
          spreadsheet: "üìä",
          presentation: "üñ•Ô∏è",
          archive: "üì¶",
          text: "üìù",
          code: "üíª",
          executable: "‚öôÔ∏è",
          font: "üî§",
        };
        for (const category in iconMap) {
          if (iconMap[category].includes(extension)) return iconChars[category];
        }
        return "üìé";
      }
      function showUserMessage(
        elementId,
        messageHTML,
        type = "info",
        autoHideDelay = 0,
      ) {
        const el = document.getElementById(elementId);
        if (!el) return;
        el.innerHTML = messageHTML;
        el.className = "";
        el.classList.add("message-base", `${type}-message`);
        el.style.display = "block";
        if ((type === "success" || type === "error") && autoHideDelay > 0) {
          setTimeout(() => {
            if (el.innerHTML === messageHTML && el.style.display !== "none") {
              el.style.display = "none";
            }
          }, autoHideDelay);
        }
      }
      function clearUserMessage(elementId) {
        const el = document.getElementById(elementId);
        if (el) {
          el.innerHTML = "";
          el.style.display = "none";
          el.className = "message-base";
        }
      }
      function getFileExtensionFromMime(mimeType) {
        if (!mimeType) return "bin";
        const parts = mimeType.split("/");
        const subtype = parts[1];
        if (subtype) {
          if (subtype === "jpeg") return "jpg";
          if (subtype === "svg+xml") return "svg";
          if (subtype.startsWith("vnd.")) {
            const specific = subtype.substring(4);
            if (specific === "microsoft.icon") {
              return "ico";
            }
          }
          return subtype.split("+")[0];
        }
        return "bin";
      }

      function renderTable() {
        const tableBody = document.getElementById("fileTableBody");
        const statusMessageEl = document.getElementById("statusMessage");
        const fileTableEl = document.getElementById("fileTable");
        tableBody.innerHTML = "";

        if (
          statusMessageEl.classList.contains("error-message") &&
          filesData.length === 0
        ) {
          fileTableEl.style.display = "none";
          return;
        }

        if (!filesData || filesData.length === 0) {
          if (!statusMessageEl.classList.contains("error-message")) {
            showUserMessage(
              "statusMessage",
              "No files found. Upload something!",
              "info",
            );
          }
          fileTableEl.style.display = "none";
          return;
        }

        fileTableEl.style.display = "";

        const sortedData = [...filesData].sort((a, b) => {
          let valA = a[currentSortColumn];
          let valB = b[currentSortColumn];
          if (currentSortColumn === "size") {
            valA = Number(a.size);
            valB = Number(b.size);
          } else if (
            currentSortColumn === "lastModified" ||
            currentSortColumn === "creationDate"
          ) {
            valA = a[currentSortColumn]
              ? new Date(a[currentSortColumn]).getTime()
              : 0;
            valB = b[currentSortColumn]
              ? new Date(b[currentSortColumn]).getTime()
              : 0;
          } else if (typeof valA === "string" && typeof valB === "string") {
            valA = valA.toLowerCase();
            valB = valB.toLowerCase();
          }
          if (valA < valB) return currentSortDirection === "asc" ? -1 : 1;
          if (valA > valB) return currentSortDirection === "asc" ? 1 : -1;
          if (a.name.toLowerCase() < b.name.toLowerCase()) return -1;
          if (a.name.toLowerCase() > b.name.toLowerCase()) return 1;
          return 0;
        });

        let totalFilesSize = 0;
        sortedData.forEach((item) => {
          totalFilesSize += Number(item.size);
          const row = tableBody.insertRow();
          row.className = "dark:hover:bg-gray-600";
          row.insertCell().outerHTML = `<td class="icon-cell dark:text-gray-300">${getIcon(item.mime_type, item.name)}</td>`;

          const nameCell = row.insertCell();
          nameCell.className = "dark:text-gray-300";
          const link = document.createElement("a");
          link.href = item.url;
          link.textContent = item.name;
          link.title = `Download ${item.name}`;
          link.className = "dark:text-blue-400 dark:hover:text-blue-300";
          link.setAttribute("download", item.name);
          nameCell.appendChild(link);

          row.insertCell().outerHTML = `<td class="dark:text-gray-300">${item.displayType || "File"}</td>`;
          row.insertCell().outerHTML = `<td class="size-cell dark:text-gray-400">${formatSize(item.size)}</td>`;
          row.insertCell().outerHTML = `<td class="date-cell dark:text-gray-400">${formatDate(item.lastModified)}</td>`;
        });

        if (!statusMessageEl.classList.contains("error-message")) {
          const summaryMessage = `Listed ${sortedData.length} item(s). Total size: ${formatSize(totalFilesSize)}.`;
          showUserMessage("statusMessage", summaryMessage, "info");
        }
      }

      function updateSortIndicators() {
        document.querySelectorAll("#fileTable th[data-sort]").forEach((th) => {
          th.classList.remove("sort-asc", "sort-desc");
          th.setAttribute("aria-sort", "none");
          if (th.dataset.sort === currentSortColumn) {
            th.classList.add(
              currentSortDirection === "asc" ? "sort-asc" : "sort-desc",
            );
            th.setAttribute(
              "aria-sort",
              currentSortDirection === "asc" ? "ascending" : "descending",
            );
          }
        });
      }

      async function fetchFiles(force = false) {
        const statusMessageEl = document.getElementById("statusMessage");
        showUserMessage("statusMessage", "Loading file list...", "info");

        try {
          const headers = {};
          if (!force && lastFilesETag) headers["If-None-Match"] = lastFilesETag;
          const response = await fetch(`${API_BASE_URL}/files`, { headers });

          if (response.status === 304) {
            clearUserMessage("statusMessage");
            renderTable();
            updateSortIndicators();
            return;
          }

          if (!response.ok) {
            const errorJson = await response.json().catch(() => ({}));
            throw new Error(
              errorJson.error || `Server responded with ${response.status}`,
            );
          }
          const responseData = await response.json();
          if (responseData.status !== "success") {
            throw new Error(
              responseData.message || "Failed to fetch file list.",
            );
          }
          filesData = responseData.data || [];
          const etag = response.headers.get("ETag");
          if (etag) {
            lastFilesETag = etag;
            localStorage.setItem("filesETag", etag);
          }
          clearUserMessage("statusMessage");
          renderTable();
        } catch (error) {
          console.error("Failed to fetch files:", error);
          showUserMessage(
            "statusMessage",
            `<strong>Error fetching files:</strong> ${error.message}`,
            "error",
            0,
          );
          filesData = [];
          renderTable();
        } finally {
          updateSortIndicators();
        }
      }

      function performUpload(
        formData,
        progressBarEl,
        statusElementId,
        buttonEl,
        buttonTextEl,
        buttonSpinnerEl,
        successCallback,
        errorCallback,
      ) {
        buttonEl.disabled = true;
        buttonTextEl.textContent = "Processing...";
        if (buttonSpinnerEl) buttonSpinnerEl.style.display = "inline-block";
        progressBarEl.style.display = "block";
        progressBarEl.value = 0;
        clearUserMessage(statusElementId);

        const xhr = new XMLHttpRequest();
        xhr.open("POST", `${API_BASE_URL}/files`, true);

        xhr.upload.onprogress = (e) => {
          if (e.lengthComputable) {
            const percentComplete = Math.round((e.loaded / e.total) * 100);
            progressBarEl.value = percentComplete;
          }
        };

        xhr.onload = function () {
          buttonEl.disabled = false;
          if (buttonSpinnerEl) buttonSpinnerEl.style.display = "none";

          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const response = JSON.parse(xhr.responseText);
              if (response.status === "success") {
                showUserMessage(
                  statusElementId,
                  response.message || "Operation successful!",
                  "success",
                  5000,
                );
                fetchFiles(true);
                if (successCallback) successCallback(response);
              } else {
                showUserMessage(
                  statusElementId,
                  `<strong>Operation failed:</strong> ${response.error || "Unknown server error."}`,
                  "error",
                  7000,
                );
                if (errorCallback) errorCallback(response);
              }
            } catch (e) {
              showUserMessage(
                statusElementId,
                "<strong>Error:</strong> Server sent an unreadable response.",
                "error",
                7000,
              );
              if (errorCallback)
                errorCallback({ error: "Unreadable server response" });
            }
          } else {
            const errResponse = JSON.parse(xhr.responseText || "{}");
            const errorMsg = `<strong>Upload failed:</strong> ${errResponse.error || `Server responded with ${xhr.status}`}`;
            showUserMessage(statusElementId, errorMsg, "error", 7000);
            if (errorCallback) errorCallback({ error: errorMsg });
          }
        };

        xhr.onerror = function () {
          if (buttonSpinnerEl) buttonSpinnerEl.style.display = "none";
          showUserMessage(
            statusElementId,
            "<strong>Error:</strong> Network issue or server unavailable.",
            "error",
            7000,
          );
          if (errorCallback) errorCallback({ error: "Network issue" });
        };
        xhr.send(formData);
      }

      uploadFormEl.addEventListener("submit", function (e) {
        e.preventDefault();
        if (fileInputEl.files.length === 0) return;
        const file = fileInputEl.files[0];
        const formData = new FormData();
        formData.append("fileToUpload", file);
        formData.append("upload_source", "direct_upload");

        performUpload(
          formData,
          uploadProgressEl,
          "uploadStatus",
          uploadButtonEl,
          uploadButtonTextEl,
          uploadButtonSpinnerEl,
          () => {
            fileInputEl.value = "";
            uploadButtonTextEl.textContent = "Upload File";
          },
          () => {
            uploadButtonTextEl.textContent = "Upload File";
          },
        );
      });

      pasteAreaEl.addEventListener("paste", function (e) {
        const items = (e.clipboardData || window.clipboardData)?.items;
        if (!items) return;
        for (const item of items) {
          if (item.type.indexOf("image") !== -1) {
            e.preventDefault();
            const imageFile = item.getAsFile();
            if (imageFile.size > MAX_CLIENT_IMAGE_PASTE_SIZE) {
              showUserMessage(
                "pasteStatus",
                `Pasted image is too large (max ${formatSize(MAX_CLIENT_IMAGE_PASTE_SIZE)}).`,
                "error",
                7000,
              );
              return;
            }
            currentPastedImageFile = imageFile;
            imagePreviewEl.src = URL.createObjectURL(currentPastedImageFile);
            imagePreviewContainerEl.style.display = "block";
            savePastedContentButtonTextEl.textContent = "Save Pasted Image";
            pasteOptionalFilenameEl.value = `image_${Date.now()}`;
            pasteOptionalFilenameEl.focus();
            return;
          }
        }
        resetPasteAreaForText();
      });
      pasteAreaEl.addEventListener("input", resetPasteAreaForText);
      function resetPasteAreaForText() {
        if (!currentPastedImageFile) return;
        currentPastedImageFile = null;
        imagePreviewContainerEl.style.display = "none";
        URL.revokeObjectURL(imagePreviewEl.src);
        imagePreviewEl.src = "#";
        savePastedContentButtonTextEl.textContent = "Save Text as File";
      }

      pasteContentFormEl.addEventListener("submit", function (e) {
        e.preventDefault();
        const formData = new FormData();
        let baseFilename = pasteOptionalFilenameEl.value.trim();

        if (currentPastedImageFile) {
          if (!baseFilename) baseFilename = `pasted_image_${Date.now()}`;
          const extension = getFileExtensionFromMime(
            currentPastedImageFile.type,
          );
          const finalFilename = baseFilename.endsWith("." + extension)
            ? baseFilename
            : `${baseFilename}.${extension}`;
          formData.append(
            "fileToUpload",
            currentPastedImageFile,
            finalFilename,
          );
          formData.append("upload_source", "paste_image");

          performUpload(
            formData,
            pasteProgressEl,
            "pasteStatus",
            savePastedContentButtonEl,
            savePastedContentButtonTextEl,
            savePastedContentButtonSpinnerEl,
            () => {
              resetPasteAreaForText();
              pasteOptionalFilenameEl.value = "";
              pasteAreaEl.value = "";
            },
            () => {
              savePastedContentButtonTextEl.textContent = "Save Pasted Image";
            },
          );
        } else {
          const textToSave = pasteAreaEl.value.trim();
          if (!textToSave) return;
          if (
            new TextEncoder().encode(textToSave).length >
            MAX_CLIENT_TEXT_CONTENT_SIZE
          ) {
            showUserMessage(
              "pasteStatus",
              `Text content is too large (max ${formatSize(MAX_CLIENT_TEXT_CONTENT_SIZE)}).`,
              "error",
              7000,
            );
            return;
          }
          if (!baseFilename) baseFilename = `text_snippet_${Date.now()}`;
          const finalFilename = baseFilename.endsWith(".txt")
            ? baseFilename
            : `${baseFilename}.txt`;
          formData.append(
            "fileToUpload",
            new Blob([textToSave], { type: "text/plain" }),
            finalFilename,
          );
          formData.append("upload_source", "paste_text");

          performUpload(
            formData,
            pasteProgressEl,
            "pasteStatus",
            savePastedContentButtonEl,
            savePastedContentButtonTextEl,
            savePastedContentButtonSpinnerEl,
            () => {
              pasteAreaEl.value = "";
              pasteOptionalFilenameEl.value = "";
              savePastedContentButtonTextEl.textContent = "Save Text as File";
            },
            () => {
              savePastedContentButtonTextEl.textContent = "Save Text as File";
            },
          );
        }
      });

      // Actions (delete/publish)
      document
        .getElementById("fileTableBody")
        .addEventListener("click", async (e) => {
          const btn = e.target.closest("button[data-action]") || e.target;
          if (!btn || !btn.dataset.action) return;

          if (btn.dataset.action === "delete") {
            const id = btn.dataset.id;
            const item = filesData.find((f) => String(f.id) === String(id));
            const name = item ? item.name : id;
            if (!confirm(`Delete ${name}?`)) return;

            try {
              const r = await fetch(
                `${API_BASE_URL}/files/${encodeURIComponent(id)}`,
                { method: "DELETE" },
              );
              if (!r.ok) {
                const j = await r.json().catch(() => ({}));
                throw new Error(j.error || `Delete failed (${r.status})`);
              }
              const j = await r.json();
              showUserMessage(
                "statusMessage",
                `Deleted: ${name}`,
                "success",
                4000,
              );
              await fetchFiles(true);
            } catch (err) {
              showUserMessage(
                "statusMessage",
                `<strong>Delete error:</strong> ${err.message}`,
                "error",
                7000,
              );
            }
          }

          if (btn.dataset.action === "publish" && PUBLISH_ENABLED) {
            const name = btn.dataset.name,
              url = btn.dataset.url;
            const payload = {
              repo: "ib-bsb-br/ib-bsb-br.github.io",
              title: `File: ${name}`,
              body: `File: ${name}\n\nURL: ${url}\n\nPublished from Inbox.`,
              tags: "drive,upload",
              layout: "post",
            };
            btn.disabled = true;
            const old = btn.textContent;
            btn.textContent = "Publishing...";
            try {
              const r = await fetch(CUT_PUBLISH_ENDPOINT, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              });
              const j = await r.json();
              if (j.status === "ok") {
                showUserMessage(
                  "statusMessage",
                  `Published: <a target="_blank" href="${j.html_url || "#"}">open on site</a>`,
                  "success",
                  7000,
                );
                if (j.html_url) window.open(j.html_url, "_blank");
              } else {
                throw new Error(j.message || j.code || "Unknown publish error");
              }
            } catch (err) {
              showUserMessage(
                "statusMessage",
                `<strong>Publish error:</strong> ${err.message}`,
                "error",
                7000,
              );
            } finally {
              btn.disabled = false;
              btn.textContent = old;
            }
          }
        });

      document.addEventListener("DOMContentLoaded", () => {
        fetchFiles();
        document
          .querySelectorAll("#fileTable th[data-sort]")
          .forEach((headerCell) => {
            headerCell.addEventListener("click", () => {
              const sortKey = headerCell.dataset.sort;
              if (currentSortColumn === sortKey) {
                currentSortDirection =
                  currentSortDirection === "asc" ? "desc" : "asc";
              } else {
                currentSortColumn = sortKey;
                currentSortDirection = "asc";
              }
              renderTable();
              updateSortIndicators();
            });
          });
        updateSortIndicators();
      });
    </script>
  </body>
</html>
